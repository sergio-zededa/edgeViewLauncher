# ZedCloud API Token Analysis

## Overview

This document provides a comprehensive analysis of how API tokens are encoded, structured, validated, and parsed in the ZedCloud microservices architecture. Tokens are generated by the `indusv2` (IAM) service and validated across the platform.

---

## 1. Token Format and Encoding

### 1.1 Token Structure

API tokens follow a **two-part format**:

```
<random-token-name>:<base64-encoded-session-key>
```

**Example:**
```
ABC1234:SGVsbG8gV29ybGQgVGVzdAo=
```

### 1.2 Components

#### Part 1: Random Token Name
- **Length**: 7 characters
- **Type**: RFC-compliant random string
- **Generation**: `zutils.GenerateRandomZStringRFC(7)`
- **Purpose**: Identifies the token namespace/prefix
- **Example**: `"XYZ9876"`

#### Part 2: Base64-Encoded Session Key
- **Length**: 128 bytes of raw data
- **Encoding**: Base64 URL encoding (`base64.URLEncoding`)
- **Generation Source**: Cryptographically secure random data
- **Purpose**: The actual unique session identifier
- **Example**: `"2D7K8L9M0N1O2P3Q4R5S6T7U8V9W0X1Y2Z3A4B5C6D7E8F9G0H1I2J3K4L5M6N7O8P9Q0R1S2T3U4V5W6X7Y8Z9A0B1C2D3E4F5G6H7I8J9K0L1M2N3O4P5Q6R7S8T9U0V1W2X3Y4Z5A6B7C8D9E0F1G2H3I4J5K6L7M8N9O0P1Q2R3S4T5U6V7W8X9Y0Z1A2B3C4D5E6F7G8H9I0J1K2L3M4N5O6P7Q8R9S0T1U2V3W4X5Y6Z7A8B9C0D1E2F3G4H5I6J7K8L9M0N1O2P3Q4R5S6T7U8V9W0X1Y2Z3A4B5C6D7E8F9G0H1I2J3K4L5"`

### 1.3 Raw Bytes

The session key is generated from **128 bytes** of cryptographically secure random data:

```go
// From sessiondata.go, lines 99-108
func GenerateRandomSessionId() (string, error) {
    sessionKey := make([]byte, 128)
    _, err := rand.Read(sessionKey)  // crypto/rand
    if err != nil {
        return "", err
    }
    b64EncodedSessionKey := base64.URLEncoding.EncodeToString(sessionKey)
    return b64EncodedSessionKey, nil
}
```

When base64-encoded, 128 bytes result in approximately 171 characters.

---

## 2. Token Validity and Expiration

### 2.1 Token Expiration Field

Yes, tokens **include validity information**. Expiration is managed through the `Token64` protobuf message:

```protobuf
// From shared.proto, lines 33-36
message Token64 {
  string base64 = 1 [(gogoproto.jsontag) = "b"];
  int64 expires = 2 [(gogoproto.jsontag) = "e"];  // Expires in epoch nanoseconds
}
```

### 2.2 SessionData Structure

Behind the scenes, session metadata is stored in the database:

```go
// From sessiondata.go, lines 303-311
type SessionData struct {
    SessionId    string      // The actual token (format: name:key)
    ExpiresAt    int64       // Expiration time in epoch nanoseconds
    EnterpriseId string      // Which enterprise owns this session
    UserId       string      // Which user owns this session
    ClientIp     string      // Client IP for audit/validation
    UserAgent    string      // User agent string
    State        string      // Session state (normal/temporary/extended)
}
```

### 2.3 Expiration Time Calculation

Expiration times are calculated based on session type and enterprise configuration:

#### Normal Session (Login)
**Source**: `session.go`, line 593

```go
sessionExpiry := time.Now().Add(time.Duration(cdConfig.NormalSessionTimeout) * time.Second).UnixNano()
```

- Uses configuration parameter: `cdConfig.NormalSessionTimeout` (in seconds)
- Result is stored as **epoch nanoseconds**

#### API Token (Extended)
**Source**: `session.go`, lines 1049-1057

```go
if refreshTime > int64(entp.APItokenExpirySec) {
    // Enterprise has a maximum API token expiry limit
    err := fmt.Errorf("requested expiry of %v should be lesser than or equal to %v", 
        refreshTime, entp.APItokenExpirySec)
    return nil, failureResp
}

expTime = time.Now().Add(time.Duration(refreshTime) * time.Second).UnixNano()
```

- Constrained by enterprise setting: `Enterprise.APItokenExpirySec`
- Request parameter `expires` is user-provided but capped
- Default: Uses enterprise's configured maximum if not specified

#### Temporary Session (Password Reset/MFA)
**Source**: `session.go`, line 745

```go
return temporaryTOTPSessionToken(ctx, user, totpTokenTTL)
```

- Uses fixed `totpTokenTTL` duration
- Shorter-lived for security-sensitive operations

### 2.4 Expiration Validation

#### At Token Creation
**Source**: `sessiondata.go`, lines 130-131

```go
now := startTime.UnixNano()
if session.ExpiresAt > 0 && now > session.ExpiresAt {
    return nil, errors.New("Invalid session expiry")
}
```

- Token cannot be created with expiration in the past

#### At Token Use (Via Redis TTL)
**Source**: `sessiondata.go`, lines 133-137

```go
var expiry time.Duration
if session.ExpiresAt > 0 {
    expiry = time.Duration(session.ExpiresAt - now)
}
_, err = rClientUserSessionInternal.Set(context.Background(), 
    session.SessionId, string(s), expiry).Result()
```

- Redis is configured with TTL = `(ExpiresAt - now_ns)`
- Expired sessions are automatically deleted by Redis
- No active server-side expiration check needed

---

## 3. Token Generation Flow

### 3.1 Generation Process

**Source**: `sessionproc.go`, lines 17-58

```
┌─────────────────────────────────────────┐
│  SessionCreate(ctx, userId, ...)        │
└──────────────────┬──────────────────────┘
                   │
                   ├─→ GenerateRandomSessionId()
                   │   └─→ crypto/rand.Read(128 bytes)
                   │   └─→ base64.URLEncoding.EncodeToString()
                   │
                   ├─→ GenerateRandomZStringRFC(7)
                   │   └─→ Random 7-char token name
                   │
                   ├─→ Combine: tokenName + ":" + b64Key
                   │
                   ├─→ Create SessionData struct
                   │   ├─→ SessionId: combined token
                   │   ├─→ ExpiresAt: calculated expiry time
                   │   ├─→ UserId: authenticated user ID
                   │   ├─→ EnterpriseId: user's enterprise
                   │   ├─→ ClientIp: from request context
                   │   └─→ UserAgent: from request context
                   │
                   ├─→ JSON marshal SessionData
                   │
                   ├─→ Store in Redis with TTL
                   │   └─→ Key: sessionToken
                   │   └─→ Value: JSON(SessionData)
                   │   └─→ TTL: ExpiresAt - now
                   │
                   └─→ Return sessionId, expiresAt, nil
```

### 3.2 Code Flow Example

```go
// From sessionproc.go, lines 28-34
b64EncodedSessionKey, err := GenerateRandomSessionId()
if err != nil {
    return sessionId, expiresAt, err
}

sessionTokenName := zutils.GenerateRandomZStringRFC(7)
sessionToken := sessionTokenName + ":" + b64EncodedSessionKey

// sessionToken now looks like: "XYZ1234:SGVs..."
```

---

## 4. Token Validation and Parsing

### 4.1 Token Lookup (Parsing)

Tokens are **not parsed or decoded** by the application. Instead, they are used as keys to look up session data:

**Source**: `sessiondata.go`, lines 152-184

```go
func (db *sessionDB) ReadByKey(ctx context.Context, key string) (*SessionData, error) {
    if key == "" {
        return nil, errors.New("Invalid: Empty session key")
    }
    
    session := &SessionData{}
    startTime := time.Now()
    
    // Simple key lookup in Redis
    v, err := rClientUserSessionInternal.Get(context.Background(), key).Result()
    if err != nil {
        db.UnsuccessfulReadCounter++
        return nil, err  // Token doesn't exist or is expired
    }
    
    // Deserialize session data
    err = json.Unmarshal([]byte(v), session)
    if err != nil {
        return nil, err
    }
    
    if session.SessionId == "" {
        return nil, errors.New("session does not exist")
    }
    
    db.SuccessfulReadCounter++
    return session, nil
}
```

### 4.2 Expiration Check Flow

```
┌──────────────────────────────┐
│  Receive API Request         │
│  with Token Header           │
└────────────────┬─────────────┘
                 │
                 ├─→ Extract token from header
                 │
                 ├─→ SessionRead(ctx, token)
                 │   └─→ Redis GET <token_key>
                 │
                 ├─→ Token in Redis?
                 │   ├─ YES: Redis TTL handles expiry
                 │   │       Return SessionData
                 │   │       ✓ Token is valid
                 │   │
                 │   └─ NO: Redis deleted due to TTL
                 │       Return error
                 │       ✗ Token is expired or invalid
                 │
                 └─→ Use SessionData for:
                     ├─ Validate user permissions
                     ├─ Audit logging (ClientIp, UserAgent)
                     └─ Route to correct enterprise
```

### 4.3 No Embedded Claims

Unlike JWTs, ZedCloud tokens have **no embedded cryptographic claims**:

- Token itself is **opaque random data** - cannot be decoded
- **All validation is server-side** - requires Redis lookup
- **No offline validation** - token cannot be verified without the database
- **No token signing** - authenticity is guaranteed by secure random generation and database storage

---

## 5. Token Types and State

### 5.1 Session States

**Source**: `session.go`, various lines

Tokens can have different states affecting their behavior:

| State | TTL Type | Purpose | Default | Configurable |
|-------|----------|---------|---------|--------------|
| **normal** | Short-lived | Interactive user sessions | `cdConfig.NormalSessionTimeout` | Yes, per enterprise |
| **temporary** | Very short | Password reset, MFA flows | `totpTokenTTL` | Fixed |
| **extended** | Long-lived | API tokens, programmatic access | User-specified, capped by `APItokenExpirySec` | Yes |

### 5.2 Token Classification

**From FillResponse() in session.go**:

```go
loginOnlyToken := false
if roleID == "" || state == SessionState_temporary {
    // LoginOnlyToken - no role attached
    // Can only be used to log in to specific enterprises
    loginOnlyToken = true
} else if user.TOTP.IsEnabled() && !fullLogin {
    // Temporary TOTP token for MFA flow
    return temporaryTOTPSessionToken(ctx, user, totpTokenTTL)
}

if loginOnlyToken {
    loginResponse.LoginToken = token
} else if state == SessionState_normal {
    loginResponse.Token = token
} else {
    // extended token
    loginResponse.ApiToken = token
}
```

---

## 6. Storage Backend

### 6.1 Redis Storage

Tokens are stored in **Redis** with the following characteristics:

**Key**: The session token string (format: `name:base64key`)
**Value**: JSON-serialized `SessionData`
**TTL**: Automatic expiration based on `ExpiresAt - now_ns`

### 6.2 Storage Example

```
Redis Key:   "ABC1234:SGVs..."
Redis Value: {
    "SessionId": "ABC1234:SGVs...",
    "ExpiresAt": 1735334708000000000,
    "EnterpriseId": "enterprise-uuid",
    "UserId": "user-uuid",
    "ClientIp": "192.168.1.100",
    "UserAgent": "Mozilla/5.0...",
    "State": "normal"
}
Redis TTL:   172800  (nanoseconds → seconds for Redis)
```

### 6.3 Automatic Expiration

**Source**: `sessiondata.go`, lines 133-137

```go
var expiry time.Duration
if session.ExpiresAt > 0 {
    expiry = time.Duration(session.ExpiresAt - now)
}
_, err = rClientUserSessionInternal.Set(context.Background(), 
    session.SessionId, string(s), expiry).Result()
```

- Redis automatically deletes the key after TTL expires
- No server-side cleanup needed
- Token validation simply checks if key exists in Redis

---

## 7. Enterprise-Level Token Policies

### 7.1 Maximum Token Expiry

**Source**: `session.go`, lines 1049-1057

Enterprises can enforce maximum token expiry times:

```go
// Enterprise configuration
type Enterprise struct {
    // ...
    APItokenExpirySec uint32  // Maximum seconds for API tokens
    // ...
}

// Token generation validation
if refreshTime > int64(entp.APItokenExpirySec) {
    return nil, errors.New(
        "requested expiry exceeds enterprise maximum"
    )
}
```

### 7.2 Override Behavior

**Source**: `session.go`, lines 1028-1137

Tokens can override defaults when `overrideDefault` is set:

```go
if isOverrideDefault {
    // Use enterprise's configured maximum
    successResp, failureResp := overrideDefaultToGenerateToken(
        ctx, refreshTime, entp, user
    )
    if failureResp != nil {
        return nil, failureResp
    }
}
```

---

## 8. Token Refresh

### 8.1 Refresh Mechanism

**Source**: `session.go`, lines 895-922

Tokens can be refreshed to extend their validity:

```go
func RefreshSession(ctx context.Context,
    refreshInput *aaa.AAARequestTokenRefresh) (
    *aaa.AAASuccessTokenRefresh,
    *aaa.AAAFailureTokenRefresh,
) {
    sessionKey := refreshInput.Token.Base64
    
    // Update expiry time
    err := SessionUpdateExpTime(ctx, sessionKey)
    if err != nil {
        return nil, failureResp
    }
    
    // Return updated token
    return successResp, nil
}
```

### 8.2 Refresh Extension

**Source**: `sessiondata.go`, lines 186-242

Expiry time is extended by the normal session timeout:

```go
func (db *sessionDB) UpdateExpTime(ctx context.Context, key string) error {
    // Read current session
    val, err := rClientUserSessionInternal.Get(
        context.Background(), key
    ).Result()
    
    session := &SessionData{}
    err = json.Unmarshal([]byte(val), session)
    
    // Extend expiry time
    newExpiry := session.ExpiresAt + 
        GetDurationInNano(cdConfig.NormalSessionTimeout)
    session.ExpiresAt = newExpiry
    
    // Update in Redis with new TTL
    expiry = time.Duration(newExpiry - now)
    rClientUserSessionInternal.Set(
        context.Background(), 
        session.SessionId, 
        string(s), 
        expiry
    )
}
```

---

## 9. Security Considerations

### 9.1 Cryptographic Security

✓ **128 bytes** of entropy from `crypto/rand.Read()`  
✓ **Base64 URL encoding** prevents special characters  
✓ **No predictable patterns** - purely random data  
✓ **Resistant to brute force** - 2^1024 possible values  

### 9.2 Server-Side Validation

✓ **No offline validation possible** - must query Redis  
✓ **No token forgery** - tokens are generated server-side only  
✓ **Audit trail** - ClientIp and UserAgent stored with token  
✓ **Automatic expiration** - Redis TTL prevents indefinite access  

### 9.3 Potential Vulnerabilities

⚠ **Token transmitted in headers** - HTTPS is required  
⚠ **Redis compromise** - would expose all active sessions  
⚠ **No token rotation** - same token valid until expiry  
⚠ **ClientIp not enforced** - stored but not validated on use  

---

## 10. Related Files and References

### Core Implementation
- `srvs/indusv2/sessionproc.go` - Token creation and management
- `srvs/indusv2/sessiondata.go` - Redis storage and retrieval
- `srvs/indusv2/session.go` - Session lifecycle (login/logout/refresh)
- `libs/zmsg/shared/shared.proto` - Token64 message definition

### Related Services
- `srvs/indusv2/` - IAM service (token generation)
- `srvs/gilas/` - API Gateway (token validation)
- `libs/zctx/` - Context utilities for token handling

### Data Structures
- `SessionData` - In-memory session representation
- `Token64` - Protobuf message with token and expiry
- `AAASuccessResponseLogin` - Login response containing token

---

## 11. API Endpoints for Token Operations

### Login
**Endpoint**: Generated by IAM service  
**Returns**: `AAASuccessResponseLogin` with `Token64`  
**Token Type**: `normal` or `loginOnlyToken`  

### Generate Token
**Endpoint**: `GenerateToken()` in `session.go`, line 974  
**Parameters**: Enterprise ID, requested expiry time  
**Returns**: `AAASuccessResponseGenerateToken` with `Token64`  
**Token Type**: `extended` (API token)  

### Refresh Token
**Endpoint**: `RefreshSession()` in `session.go`, line 895  
**Parameters**: Current token  
**Returns**: Updated `Token64` with new expiry  
**Effect**: Extends expiry by `NormalSessionTimeout`  

### Logout
**Endpoint**: `Logout()` in `session.go`, line 835  
**Parameters**: Token to revoke  
**Effect**: Immediately deletes token from Redis  

---

## 12. Summary Table

| Aspect | Details |
|--------|---------|
| **Format** | `<7-char-random>:<base64-128-bytes>` |
| **Encoding** | Base64 URL encoding |
| **Size** | ~180 characters |
| **Entropy** | 1024 bits (128 bytes) |
| **Expiration** | Stored as epoch nanoseconds in SessionData |
| **Default TTL** | `cdConfig.NormalSessionTimeout` (seconds) |
| **API Token TTL** | User-specified, capped by `Enterprise.APItokenExpirySec` |
| **Storage** | Redis with automatic TTL expiration |
| **Validation** | Server-side Redis lookup only |
| **Claims** | None - purely opaque random data |
| **Signing** | None - randomness + database provides authenticity |
| **Offline Verification** | Not possible |
| **Refresh** | Extends expiry by `NormalSessionTimeout` |
| **Revocation** | Immediate Redis deletion |
| **Audit Info** | ClientIp, UserAgent stored with token |

---

## 13. Code Snippets for Quick Reference

### Creating a Token
```go
b64EncodedSessionKey, _ := GenerateRandomSessionId()  // 128 bytes → base64
sessionTokenName := zutils.GenerateRandomZStringRFC(7)
sessionToken := sessionTokenName + ":" + b64EncodedSessionKey

sessionStruct := SessionData{
    SessionId:    sessionToken,
    ExpiresAt:    time.Now().Add(time.Duration(ttl)*time.Second).UnixNano(),
    EnterpriseId: enterpriseId,
    UserId:       userId,
    ClientIp:     clientIp,
    UserAgent:    userAgent,
    State:        state,
}

sessiondb.Create(ctx, &sessionStruct)
```

### Validating a Token
```go
sessionData, err := sessiondb.ReadByKey(ctx, token)
if err != nil {
    // Token expired, invalid, or doesn't exist
    return unauthorizedError
}

// Token is valid
userId := sessionData.UserId
enterpriseId := sessionData.EnterpriseId
```

### Refreshing a Token
```go
SessionUpdateExpTime(ctx, token)
// Extends ExpiresAt by NormalSessionTimeout
```

---

**Document Version**: 1.0  
**Last Updated**: 2025-11-26  
**Scope**: ZedCloud IAM Token Implementation  
